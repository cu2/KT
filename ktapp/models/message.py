from django.db import models
from django.db.models import Q
from django.db.models.signals import post_delete
from django.dispatch.dispatcher import receiver
from django.utils.html import strip_tags

from ktapp import utils as kt_utils


class OldMessage(models.Model):
    sent_by = models.ForeignKey('KTUser', blank=True, null=True, related_name='sent_message', on_delete=models.SET_NULL)
    sent_at = models.DateTimeField(auto_now_add=True)
    content = models.TextField()  # original w bbcode
    content_html = models.TextField()  # autogenerated from content
    content_old_html = models.TextField(blank=True)  # migrated from old db
    owned_by = models.ForeignKey('KTUser', related_name='owned_message', on_delete=models.CASCADE)
    sent_to = models.ManyToManyField('KTUser', blank=True, related_name='received_message')
    private = models.BooleanField(default=True)  # private = only one recipient

    class Meta:
        index_together = [
            ['owned_by', 'sent_at'],
        ]

    def recipients(self):
        return self.sent_to.all().order_by('username', 'id')

    def save(self, *args, **kwargs):
        self.content = strip_tags(self.content)
        self.content_html = kt_utils.bbcode_to_html(self.content)
        super(OldMessage, self).save(*args, **kwargs)

    @classmethod
    def send_message(cls, sent_by, content, recipients):
        from .user_action import IgnoreUser
        recipients = set(recipients)
        is_private = len(recipients)==1
        excluded_recipients = set()
        if sent_by:
            for ignore in IgnoreUser.objects.filter(whom=sent_by, ignore_pm=True):
                excluded_recipients.add(ignore.who)
        if sent_by is None:
            owners = recipients
        else:
            owners = recipients | {sent_by}
        message_times = []
        for owner in owners - excluded_recipients:
            message = OldMessage.objects.create(
                sent_by=sent_by,
                content=content,
                owned_by=owner,
                private=is_private,
            )
            if sent_by is None or owner != sent_by:
                message_times.append((owner, message.sent_at))
            for recipient in recipients:
                message.sent_to.add(recipient)
            message.save()
            owner.number_of_messages = OldMessage.objects.filter(owned_by=owner).count()
            owner.save(update_fields=['number_of_messages'])
        for recipient, message_sent_at in message_times:
            recipient.number_of_messages = OldMessage.objects.filter(owned_by=recipient).count()
            if recipient.last_message_at is None or recipient.last_message_at < message_sent_at:
                recipient.last_message_at = message_sent_at
            recipient.save(update_fields=['number_of_messages', 'last_message_at'])
        if sent_by and is_private:
            other = list(recipients)[0]
            MessageCountCache.update_cache(owned_by=sent_by, partner=other)
            if other not in excluded_recipients:
                MessageCountCache.update_cache(owned_by=other, partner=sent_by)


@receiver(post_delete, sender=OldMessage)
def delete_message(sender, instance, **kwargs):
    instance.owned_by.number_of_messages = OldMessage.objects.filter(owned_by=instance.owned_by).count()
    if OldMessage.objects.filter(owned_by=instance.owned_by).exclude(sent_by=instance.owned_by).count() > 0:
        instance.owned_by.last_message_at = OldMessage.objects.filter(owned_by=instance.owned_by).exclude(sent_by=instance.owned_by).latest('sent_at').sent_at
    else:
        instance.owned_by.last_message_at = None
    instance.owned_by.save(update_fields=['number_of_messages', 'last_message_at'])
    # NOTE: recipients are not available here, so MessageCountCache.update_cache lives in view function


class MessageCountCache(models.Model):
    owned_by = models.ForeignKey('KTUser', related_name='owned_message_count', on_delete=models.CASCADE)
    partner = models.ForeignKey('KTUser', related_name='partner_message_count', on_delete=models.CASCADE)
    number_of_messages = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = ['owned_by', 'partner']

    @classmethod
    def get_count(cls, owned_by, partner):
        if owned_by == partner:
            return 0
        try:
            return cls.objects.get(owned_by=owned_by, partner=partner).number_of_messages
        except cls.DoesNotExist:
            pass
        return cls.update_cache(owned_by, partner)

    @classmethod
    def update_cache(cls, owned_by, partner):
        if owned_by == partner:
            return 0
        number_of_messages = OldMessage.objects.filter(private=True).filter(owned_by=owned_by).filter(Q(sent_by=partner) | Q(sent_to=partner)).count()
        item, created = cls.objects.get_or_create(owned_by=owned_by, partner=partner)
        item.number_of_messages = number_of_messages
        item.save()
        return number_of_messages
