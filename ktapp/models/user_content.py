from urlparse import urlparse

from django.db import models, connection
from django.db.models.signals import post_delete
from django.dispatch.dispatcher import receiver
from django.template.defaultfilters import slugify
from django.utils.html import strip_tags

from ktapp import utils as kt_utils


class FilmUserContent(models.Model):
    film = models.ForeignKey('Film')
    created_by = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL)
    created_at = models.DateTimeField(auto_now_add=True)
    content = models.TextField()  # original w bbcode
    content_html = models.TextField()  # autogenerated from content
    content_old_html = models.TextField(blank=True)  # migrated from old db

    class Meta:
        abstract = True
        ordering = ['created_at']
        get_latest_by = 'created_at'


class Quote(FilmUserContent):

    def save(self, *args, **kwargs):
        self.content = strip_tags(self.content)
        self.content_html = kt_utils.bbcode_to_html(self.content)
        super(Quote, self).save(*args, **kwargs)
        self.film.number_of_quotes = self.film.quote_set.count()
        self.film.save(update_fields=['number_of_quotes'])


@receiver(post_delete, sender=Quote)
def delete_quote(sender, instance, **kwargs):
    instance.film.number_of_quotes = instance.film.quote_set.count()
    instance.film.save(update_fields=['number_of_quotes'])


class Trivia(FilmUserContent):
    spoiler = models.BooleanField(default=False)

    def save(self, *args, **kwargs):
        self.content = strip_tags(self.content)
        self.content_html = kt_utils.bbcode_to_html(self.content)
        super(Trivia, self).save(*args, **kwargs)
        self.film.number_of_trivias = self.film.trivia_set.count()
        self.film.save(update_fields=['number_of_trivias'])


@receiver(post_delete, sender=Trivia)
def delete_trivia(sender, instance, **kwargs):
    instance.film.number_of_trivias = instance.film.trivia_set.count()
    instance.film.save(update_fields=['number_of_trivias'])


class Review(FilmUserContent):
    approved = models.BooleanField(default=False)
    snippet = models.TextField(blank=True)

    def save(self, *args, **kwargs):
        self.content = strip_tags(self.content)
        self.content_html = kt_utils.bbcode_to_html(self.content)
        self.snippet = strip_tags(self.content_html)[:500]
        super(Review, self).save(*args, **kwargs)
        self.film.number_of_reviews = self.film.review_set.filter(approved=True).count()
        self.film.save(update_fields=['number_of_reviews'])
        self.created_by.number_of_reviews = Review.objects.filter(created_by=self.created_by, approved=True).count()
        self.created_by.save(update_fields=['number_of_reviews'])

    def __unicode__(self):
        return self.content[:50]


@receiver(post_delete, sender=Review)
def delete_review(sender, instance, **kwargs):
    instance.film.number_of_reviews = instance.film.review_set.filter(approved=True).count()
    instance.film.save(update_fields=['number_of_reviews'])
    instance.created_by.number_of_reviews = Review.objects.filter(created_by=instance.created_by, approved=True).count()
    instance.created_by.save(update_fields=['number_of_reviews'])


class Biography(models.Model):
    artist = models.ForeignKey('Artist')
    created_by = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL)
    created_at = models.DateTimeField(auto_now_add=True)
    content = models.TextField()  # original w bbcode
    content_html = models.TextField()  # autogenerated from content
    content_old_html = models.TextField(blank=True)  # migrated from old db
    approved = models.BooleanField(default=False)
    snippet = models.TextField(blank=True)

    def save(self, *args, **kwargs):
        self.content = strip_tags(self.content)
        self.content_html = kt_utils.bbcode_to_html(self.content)
        self.snippet = strip_tags(self.content_html)[:500]
        super(Biography, self).save(*args, **kwargs)
        self.created_by.number_of_bios = Biography.objects.filter(created_by=self.created_by, approved=True).count()
        self.created_by.save(update_fields=['number_of_bios'])

    def __unicode__(self):
        return self.content[:50]

    class Meta:
        ordering = ['-created_at']
        get_latest_by = 'created_at'


@receiver(post_delete, sender=Biography)
def delete_biography(sender, instance, **kwargs):
    instance.created_by.number_of_bios = Biography.objects.filter(created_by=instance.created_by, approved=True).count()
    instance.created_by.save(update_fields=['number_of_bios'])


class Link(models.Model):
    name = models.CharField(max_length=250)
    url = models.CharField(max_length=250)
    film = models.ForeignKey('Film', blank=True, null=True, on_delete=models.SET_NULL)
    artist = models.ForeignKey('Artist', blank=True, null=True, on_delete=models.SET_NULL)
    link_domain = models.CharField(max_length=250)
    created_by = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL)
    created_at = models.DateTimeField(auto_now_add=True)
    LINK_TYPE_OFFICIAL = 'O'
    LINK_TYPE_REVIEWS = 'R'
    LINK_TYPE_INTERVIEWS = 'I'
    LINK_TYPE_OTHER = '-'
    LINK_TYPES = [
        (LINK_TYPE_OFFICIAL, 'Official pages'),
        (LINK_TYPE_REVIEWS, 'Reviews'),
        (LINK_TYPE_INTERVIEWS, 'Interviews'),
        (LINK_TYPE_OTHER, 'Other pages'),
    ]
    link_type = models.CharField(max_length=1, choices=LINK_TYPES, default=LINK_TYPE_OTHER)
    lead = models.TextField(blank=True)
    author = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL, related_name='authored_link')
    featured = models.BooleanField(default=False)

    def save(self, *args, **kwargs):
        self.link_domain = urlparse(self.url).netloc
        super(Link, self).save(*args, **kwargs)
        if self.film:
            self.film.number_of_links = self.film.link_set.count()
            self.film.save(update_fields=['number_of_links'])
            if self.author:
                self.author.number_of_links = Link.objects.filter(author=self.author).count()
                self.author.save(update_fields=['number_of_links'])

    def __unicode__(self):
        return self.name


@receiver(post_delete, sender=Link)
def delete_link(sender, instance, **kwargs):
    if instance.film:
        instance.film.number_of_links = instance.film.link_set.count()
        instance.film.save(update_fields=['number_of_links'])
        if instance.author:
            instance.author.number_of_links = Link.objects.filter(author=instance.author).count()
            instance.author.save(update_fields=['number_of_links'])


class Comment(models.Model):
    DOMAIN_FILM = 'F'
    DOMAIN_TOPIC = 'T'
    DOMAIN_POLL = 'P'
    DOMAINS = [
        (DOMAIN_FILM, 'Film'),
        (DOMAIN_TOPIC, 'Topic'),
        (DOMAIN_POLL, 'Poll'),
    ]
    domain = models.CharField(max_length=1, choices=DOMAINS, default=DOMAIN_FILM)
    film = models.ForeignKey('Film', blank=True, null=True)
    topic = models.ForeignKey('Topic', blank=True, null=True)
    poll = models.ForeignKey('Poll', blank=True, null=True)
    created_by = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL)
    created_at = models.DateTimeField(auto_now_add=True)
    content = models.TextField()  # original w bbcode
    content_html = models.TextField()  # autogenerated from content
    content_old_html = models.TextField(blank=True)  # migrated from old db
    reply_to = models.ForeignKey('self', blank=True, null=True, on_delete=models.SET_NULL)
    rating = models.PositiveSmallIntegerField(blank=True, null=True)  # cache for film comments
    serial_number = models.PositiveIntegerField(default=0)
    serial_number_by_user = models.PositiveIntegerField(default=0)
    hidden = models.BooleanField(default=False)

    def __unicode__(self):
        return self.content[:100]

    class Meta:
        ordering = ['-created_at']
        get_latest_by = 'created_at'
        index_together = [
            ['created_at'],
            ['domain', 'created_at'],
            ['created_by', 'serial_number_by_user', 'created_at'],
            ['film', 'serial_number'],
            ['topic', 'serial_number'],
        ]

    @property
    def domain_object(self):
        if self.domain == Comment.DOMAIN_FILM:
            return self.film
        elif self.domain == Comment.DOMAIN_TOPIC:
            return self.topic
        elif self.domain == Comment.DOMAIN_POLL:
            return self.poll
        raise Exception

    def editable(self):
        return self.domain_object.last_comment_id == self.id

    def save(self, *args, **kwargs):
        from .user_action import Vote
        """Save comment and update domain object as well"""
        self.content = strip_tags(self.content)
        self.content_html = kt_utils.bbcode_to_html(self.content)
        if 'domain' in kwargs:
            self.serial_number = kwargs['domain'].comment_set.count() + 1
            self.serial_number_by_user = self.created_by.comment_set.count() + 1
            if self.domain == Comment.DOMAIN_FILM:
                try:
                    vote = Vote.objects.get(film=self.film, user=self.created_by)
                    self.rating = vote.rating
                except Vote.DoesNotExist:
                    self.rating = None
        super_kwargs = {key: value for key, value in kwargs.iteritems() if key != 'domain'}
        super(Comment, self).save(*args, **super_kwargs)
        if 'domain' in kwargs:
            kwargs['domain'].number_of_comments = kwargs['domain'].comment_set.count()
            kwargs['domain'].last_comment = kwargs['domain'].comment_set.latest()
            kwargs['domain'].save(update_fields=['number_of_comments', 'last_comment'])
            self.created_by.latest_comments = ','.join([unicode(c.id) for c in self.created_by.comment_set.all().order_by('-created_at', '-id')[:100]])
            self.created_by.number_of_comments = self.created_by.comment_set.count()
            self.created_by.number_of_film_comments = self.created_by.comment_set.filter(domain=Comment.DOMAIN_FILM).count()
            self.created_by.number_of_topic_comments = self.created_by.comment_set.filter(domain=Comment.DOMAIN_TOPIC).count()
            self.created_by.number_of_poll_comments = self.created_by.comment_set.filter(domain=Comment.DOMAIN_POLL).count()
            self.created_by.save(update_fields=[
                'latest_comments', 'number_of_comments',
                'number_of_film_comments', 'number_of_topic_comments', 'number_of_poll_comments',
            ])

    @classmethod
    def fix_comments(cls, domain, domain_object):
        if domain == cls.DOMAIN_FILM:
            domain_id_field = 'film_id'
        elif domain == cls.DOMAIN_TOPIC:
            domain_id_field = 'topic_id'
        elif domain == cls.DOMAIN_POLL:
            domain_id_field = 'poll_id'
        else:
            return
        cursor = connection.cursor()
        cursor.execute('''
            UPDATE ktapp_comment
            SET serial_number = 0
            WHERE
              domain = '{domain}'
              AND {domain_id_field} = {domain_id}
        '''.format(
            domain=domain,
            domain_id_field=domain_id_field,
            domain_id=domain_object.id,
        ))
        cursor.execute('''
            UPDATE
              ktapp_comment c, (
                SELECT
                  c.id, @a:=@a+1 AS serial_number
                FROM
                  ktapp_comment c,
                  (SELECT @a:= 0) AS a
                WHERE
                  domain = '{domain}'
                  AND {domain_id_field} = {domain_id}
                ORDER BY
                  c.created_at, c.id
              ) t
            SET c.serial_number = t.serial_number
            WHERE c.id = t.id
        '''.format(
            domain=domain,
            domain_id_field=domain_id_field,
            domain_id=domain_object.id,
        ))
        domain_object.number_of_comments = domain_object.comment_set.count()
        if domain_object.number_of_comments:
            domain_object.last_comment = domain_object.comment_set.latest()
        else:
            domain_object.last_comment = None
        domain_object.save(update_fields=['number_of_comments', 'last_comment'])


@receiver(post_delete, sender=Comment)
def delete_comment(sender, instance, **kwargs):
    if instance.domain == Comment.DOMAIN_FILM:
        domain = instance.film
        remaining_comments = Comment.objects.filter(domain=instance.domain, film=instance.film)
    elif instance.domain == Comment.DOMAIN_TOPIC:
        domain = instance.topic
        remaining_comments = Comment.objects.filter(domain=instance.domain, topic=instance.topic)
    elif instance.domain == Comment.DOMAIN_POLL:
        domain = instance.poll
        remaining_comments = Comment.objects.filter(domain=instance.domain, poll=instance.poll)
    else:
        return
    for idx, remaining_comment in enumerate(remaining_comments.order_by('created_at', 'id')):
        remaining_comment.serial_number = idx + 1
        remaining_comment.save()
    domain.number_of_comments = domain.comment_set.count()
    if domain.number_of_comments > 0:
        domain.last_comment = domain.comment_set.latest()
    else:
        domain.last_comment = None
    domain.save(update_fields=['number_of_comments', 'last_comment'])
    for idx, remaining_comment in enumerate(Comment.objects.filter(created_by=instance.created_by).order_by('created_at', 'id')):
        remaining_comment.serial_number_by_user = idx + 1
        remaining_comment.save()
    instance.created_by.latest_comments = ','.join([unicode(c.id) for c in instance.created_by.comment_set.all().order_by('-created_at', '-id')[:100]])
    instance.created_by.number_of_comments = instance.created_by.comment_set.count()
    instance.created_by.number_of_film_comments = instance.created_by.comment_set.filter(domain=Comment.DOMAIN_FILM).count()
    instance.created_by.number_of_topic_comments = instance.created_by.comment_set.filter(domain=Comment.DOMAIN_TOPIC).count()
    instance.created_by.number_of_poll_comments = instance.created_by.comment_set.filter(domain=Comment.DOMAIN_POLL).count()
    instance.created_by.save(update_fields=[
        'latest_comments', 'number_of_comments',
        'number_of_film_comments', 'number_of_topic_comments', 'number_of_poll_comments',
    ])


class Topic(models.Model):
    title = models.CharField(max_length=250)
    number_of_comments = models.PositiveIntegerField(default=0)
    created_by = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL)
    created_at = models.DateTimeField(auto_now_add=True)
    last_comment = models.ForeignKey(Comment, blank=True, null=True, related_name='last_topic_comment', on_delete=models.SET_NULL)
    slug_cache = models.CharField(max_length=250, blank=True)
    closed_until = models.DateTimeField(blank=True, null=True)
    game_mode = models.BooleanField(default=False)

    def __unicode__(self):
        return self.title

    class Meta:
        ordering = ['-last_comment__id']

    def save(self, *args, **kwargs):
        self.slug_cache = slugify(self.title)
        super(Topic, self).save(*args, **kwargs)


class Poll(models.Model):
    title = models.CharField(max_length=250)
    created_by = models.ForeignKey('KTUser', blank=True, null=True, on_delete=models.SET_NULL)
    created_at = models.DateTimeField(auto_now_add=True)
    nominated_by = models.CharField(max_length=250, blank=True, null=True)
    open_from = models.DateTimeField(blank=True, null=True)
    open_until = models.DateTimeField(blank=True, null=True)
    STATE_WAITING_FOR_APPROVAL = 'W'
    STATE_APPROVED = 'A'
    STATE_OPEN = 'O'
    STATE_CLOSED = 'C'
    STATES = [
        (STATE_WAITING_FOR_APPROVAL, 'Waiting for approval'),
        (STATE_APPROVED, 'Approved'),
        (STATE_OPEN, 'Open'),
        (STATE_CLOSED, 'Closed'),
    ]
    state = models.CharField(max_length=1, choices=STATES, default=STATE_WAITING_FOR_APPROVAL)
    number_of_comments = models.PositiveIntegerField(default=0)
    number_of_votes = models.PositiveIntegerField(default=0)
    number_of_people = models.PositiveIntegerField(default=0)
    slug_cache = models.CharField(max_length=250, blank=True)
    last_comment = models.ForeignKey(Comment, blank=True, null=True, related_name='last_poll_comment', on_delete=models.SET_NULL)

    def __unicode__(self):
        return self.title

    def save(self, *args, **kwargs):
        self.slug_cache = slugify(self.title)
        super(Poll, self).save(*args, **kwargs)

    def pollchoices(self):
        return self.pollchoice_set.all()


class PollChoice(models.Model):
    poll = models.ForeignKey(Poll)
    choice = models.CharField(max_length=250)
    serial_number = models.PositiveSmallIntegerField(default=0)
    number_of_votes = models.PositiveIntegerField(default=0)

    def __unicode__(self):
        return self.choice

    class Meta:
        ordering = ['poll', 'serial_number']


class PollVote(models.Model):
    user = models.ForeignKey('KTUser')
    pollchoice = models.ForeignKey(PollChoice)

    class Meta:
        unique_together = ['user', 'pollchoice']

    def __unicode__(self):
        return u'{}:{}'.format(self.user, self.pollchoice)

    def save(self, *args, **kwargs):
        super(PollVote, self).save(*args, **kwargs)
        self.pollchoice.number_of_votes = self.pollchoice.pollvote_set.count()
        self.pollchoice.save(update_fields=['number_of_votes'])
        self.pollchoice.poll.number_of_votes = sum([pc.number_of_votes for pc in self.pollchoice.poll.pollchoice_set.all()])
        users = set()
        for pc in self.pollchoice.poll.pollchoice_set.all():
            for pv in PollVote.objects.filter(pollchoice=pc):
                users.add(pv.user)
        self.pollchoice.poll.number_of_people = len(users)
        self.pollchoice.poll.save(update_fields=['number_of_votes', 'number_of_people'])


@receiver(post_delete, sender=PollVote)
def delete_pollvote(sender, instance, **kwargs):
    instance.pollchoice.number_of_votes = instance.pollchoice.pollvote_set.count()
    instance.pollchoice.save(update_fields=['number_of_votes'])
    instance.pollchoice.poll.number_of_votes = sum([pc.number_of_votes for pc in instance.pollchoice.poll.pollchoice_set.all()])
    users = set()
    for pc in instance.pollchoice.poll.pollchoice_set.all():
        for pv in PollVote.objects.filter(pollchoice=pc):
            users.add(pv.user)
    instance.pollchoice.poll.number_of_people = len(users)
    instance.pollchoice.poll.save(update_fields=['number_of_votes', 'number_of_people'])


class UserToplist(models.Model):
    title = models.CharField(max_length=250)
    created_by = models.ForeignKey('KTUser')
    created_at = models.DateTimeField(auto_now_add=True)
    ordered = models.BooleanField(default=True)
    quality = models.BooleanField(default=True)  # if all items have comments, show up more often
    number_of_items = models.PositiveSmallIntegerField()
    TOPLIST_TYPE_FILM = 'F'
    TOPLIST_TYPE_DIRECTOR = 'D'
    TOPLIST_TYPE_ACTOR = 'A'
    TOPLIST_TYPES = [
        (TOPLIST_TYPE_FILM, 'Film'),
        (TOPLIST_TYPE_DIRECTOR, 'Director'),
        (TOPLIST_TYPE_ACTOR, 'Actor'),
    ]
    toplist_type = models.CharField(max_length=1, choices=TOPLIST_TYPES, default=TOPLIST_TYPE_FILM)
    slug_cache = models.CharField(max_length=250, blank=True)

    def __unicode__(self):
        return self.title

    def save(self, *args, **kwargs):
        self.slug_cache = slugify(self.title)
        super(UserToplist, self).save(*args, **kwargs)
        self.created_by.number_of_toplists = UserToplist.objects.filter(created_by=self.created_by).count()
        self.created_by.save(update_fields=['number_of_toplists'])


@receiver(post_delete, sender=UserToplist)
def delete_usertoplist(sender, instance, **kwargs):
    instance.created_by.number_of_toplists = UserToplist.objects.filter(created_by=instance.created_by).count()
    instance.created_by.save(update_fields=['number_of_toplists'])


class UserToplistItem(models.Model):
    usertoplist = models.ForeignKey(UserToplist)
    serial_number = models.PositiveSmallIntegerField(default=0)
    film = models.ForeignKey('Film', blank=True, null=True)
    director = models.ForeignKey('Artist', blank=True, null=True, related_name='director_usertoplist')
    actor = models.ForeignKey('Artist', blank=True, null=True, related_name='actor_usertoplist')
    comment = models.TextField()
